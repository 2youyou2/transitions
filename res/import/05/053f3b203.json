[{"__type__":"cc.EffectAsset","_name":"inverted-page-curl","techniques":[{"passes":[{"blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"texture2":{"value":"white","type":29},"time":{"value":[0],"type":13}},"program":"inverted-page-curl|vs|fs"}]}],"shaders":[{"hash":3326262529,"glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin lowp vec4 a_color;\nin mediump vec2 a_uv0;\nout mediump vec2 v_uv0;\nout lowp vec4 v_color;\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = mvp * vec4(a_position, 1);\n}","frag":"\nprecision highp float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nin mediump vec2 v_uv0;\nuniform Time {\n  float time;\n};\nin lowp vec4 v_color;\nvec4 getFromColor(vec2 uv) {\n  return texture(texture, uv);\n}\nvec4 getToColor(vec2 uv) {\n  return texture(texture2, uv);\n}\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.5;\nfloat amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\nconst float PI = 3.141592653589793;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nfloat cylinderCenter = amount;\nfloat cylinderAngle = 2.0 * PI * amount;\nconst float cylinderRadius = 1.0 / PI / 2.0;\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n  float hitPoint = hitAngle / (2.0 * PI);\n  point.y = hitPoint;\n  return rrotation * point;\n}\nvec4 antiAlias(vec4 color1, vec4 color2, float distanc)\n{\n  distanc *= scale;\n  if (distanc < 0.0) return color2;\n  if (distanc > 2.0) return color1;\n  float dd = pow(1.0 - distanc / 2.0, sharpness);\n  return ((color2 - color1) * dd) + color1;\n}\nfloat distanceToEdge(vec3 point)\n{\n  float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n  float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n  if (point.x < 0.0) dx = -point.x;\n  if (point.x > 1.0) dx = point.x - 1.0;\n  if (point.y < 0.0) dy = -point.y;\n  if (point.y > 1.0) dy = point.y - 1.0;\n  if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n  return min(dx, dy);\n}\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n  float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n  vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n  if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n    return getToColor(p);\n  }\n  if (yc > 0.0) return getFromColor(p);\n  vec4 color = getFromColor(point.xy);\n  vec4 tcolor = vec4(0.0);\n  return antiAlias(color, tcolor, distanceToEdge(point));\n}\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n  float shadow = distanceToEdge(point) * 30.0;\n  shadow = (1.0 - shadow) / 3.0;\n  if (shadow < 0.0) shadow = 0.0; else shadow *= amount;\n  vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n  shadowColor.r -= shadow;\n  shadowColor.g -= shadow;\n  shadowColor.b -= shadow;\n  return shadowColor;\n}\nvec4 backside(float yc, vec3 point)\n{\n  vec4 color = getFromColor(point.xy);\n  float gray = (color.r + color.b + color.g) / 15.0;\n  gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n  color.rgb = vec3(gray);\n  return color;\n}\nvec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation)\n{\n  float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n  shado *= 1.0 - abs(point.x - 0.5);\n  yc = (-cylinderRadius - cylinderRadius - yc);\n  float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n  point = hitPoint(hitAngle, yc, point, rrotation);\n  if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)) {\n    shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n    shado *= pow(-yc / cylinderRadius, 3.0);\n    shado *= 0.5;\n  }\n  else {\n    shado = 0.0;\n  }\n  return vec4(getToColor(p).rgb - shado, 1.0);\n}\nvec4 transition(vec2 p) {\n  const float angle = 100.0 * PI / 180.0;\n  float c = cos(-angle);\n  float s = sin(-angle);\n  mat3 rotation = mat3(\n    c, s, 0,\n    -s, c, 0,\n    -0.801, 0.8900, 1\n  );\n  c = cos(angle);\n  s = sin(angle);\n  mat3 rrotation = mat3(\n    c, s, 0,\n    -s, c, 0,\n    0.98500, 0.985, 1\n  );\n  vec3 point = rotation * vec3(p, 1.0);\n  float yc = point.y - cylinderCenter;\n  if (yc < -cylinderRadius) {\n    return behindSurface(p, yc, point, rrotation);\n  }\n  if (yc > cylinderRadius) {\n    return getFromColor(p);\n  }\n  float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n  float hitAngleMod = mod(hitAngle, 2.0 * PI);\n  if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI / 2.0 && amount < 0.0)) {\n    return seeThrough(yc, p, rotation, rrotation);\n  }\n  point = hitPoint(hitAngle, yc, point, rrotation);\n  if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n    return seeThroughWithShadow(yc, p, point, rotation, rrotation);\n  }\n  vec4 color = backside(yc, point);\n  vec4 otherColor;\n  if (yc < 0.0) {\n    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n    shado *= pow(-yc / cylinderRadius, 3.0);\n    shado *= 0.5;\n    otherColor = vec4(0.0, 0.0, 0.0, shado);\n  }\n  else {\n    otherColor = getFromColor(p);\n  }\n  color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n  vec4 cl = seeThroughWithShadow(yc, p, point, rotation, rrotation);\n  float dist = distanceToEdge(point);\n  return antiAlias(color, cl, dist);\n}\nvoid main () {\n  gl_FragColor = v_color * transition(v_uv0);\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nvarying lowp vec4 v_color;\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = mvp * vec4(a_position, 1);\n}","frag":"\nprecision highp float;\nuniform sampler2D texture;\nuniform sampler2D texture2;\nvarying mediump vec2 v_uv0;\nuniform float time;\nvarying lowp vec4 v_color;\nvec4 getFromColor(vec2 uv) {\n  return texture2D(texture, uv);\n}\nvec4 getToColor(vec2 uv) {\n  return texture2D(texture2, uv);\n}\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.5;\nfloat amount = time * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\nconst float PI = 3.141592653589793;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nfloat cylinderCenter = amount;\nfloat cylinderAngle = 2.0 * PI * amount;\nconst float cylinderRadius = 1.0 / PI / 2.0;\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {\n  float hitPoint = hitAngle / (2.0 * PI);\n  point.y = hitPoint;\n  return rrotation * point;\n}\nvec4 antiAlias(vec4 color1, vec4 color2, float distanc)\n{\n  distanc *= scale;\n  if (distanc < 0.0) return color2;\n  if (distanc > 2.0) return color1;\n  float dd = pow(1.0 - distanc / 2.0, sharpness);\n  return ((color2 - color1) * dd) + color1;\n}\nfloat distanceToEdge(vec3 point)\n{\n  float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n  float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n  if (point.x < 0.0) dx = -point.x;\n  if (point.x > 1.0) dx = point.x - 1.0;\n  if (point.y < 0.0) dy = -point.y;\n  if (point.y > 1.0) dy = point.y - 1.0;\n  if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n  return min(dx, dy);\n}\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n  float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n  vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n  if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {\n    return getToColor(p);\n  }\n  if (yc > 0.0) return getFromColor(p);\n  vec4 color = getFromColor(point.xy);\n  vec4 tcolor = vec4(0.0);\n  return antiAlias(color, tcolor, distanceToEdge(point));\n}\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n  float shadow = distanceToEdge(point) * 30.0;\n  shadow = (1.0 - shadow) / 3.0;\n  if (shadow < 0.0) shadow = 0.0; else shadow *= amount;\n  vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n  shadowColor.r -= shadow;\n  shadowColor.g -= shadow;\n  shadowColor.b -= shadow;\n  return shadowColor;\n}\nvec4 backside(float yc, vec3 point)\n{\n  vec4 color = getFromColor(point.xy);\n  float gray = (color.r + color.b + color.g) / 15.0;\n  gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n  color.rgb = vec3(gray);\n  return color;\n}\nvec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation)\n{\n  float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n  shado *= 1.0 - abs(point.x - 0.5);\n  yc = (-cylinderRadius - cylinderRadius - yc);\n  float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n  point = hitPoint(hitAngle, yc, point, rrotation);\n  if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)) {\n    shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n    shado *= pow(-yc / cylinderRadius, 3.0);\n    shado *= 0.5;\n  }\n  else {\n    shado = 0.0;\n  }\n  return vec4(getToColor(p).rgb - shado, 1.0);\n}\nvec4 transition(vec2 p) {\n  const float angle = 100.0 * PI / 180.0;\n  float c = cos(-angle);\n  float s = sin(-angle);\n  mat3 rotation = mat3(\n    c, s, 0,\n    -s, c, 0,\n    -0.801, 0.8900, 1\n  );\n  c = cos(angle);\n  s = sin(angle);\n  mat3 rrotation = mat3(\n    c, s, 0,\n    -s, c, 0,\n    0.98500, 0.985, 1\n  );\n  vec3 point = rotation * vec3(p, 1.0);\n  float yc = point.y - cylinderCenter;\n  if (yc < -cylinderRadius) {\n    return behindSurface(p, yc, point, rrotation);\n  }\n  if (yc > cylinderRadius) {\n    return getFromColor(p);\n  }\n  float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n  float hitAngleMod = mod(hitAngle, 2.0 * PI);\n  if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI / 2.0 && amount < 0.0)) {\n    return seeThrough(yc, p, rotation, rrotation);\n  }\n  point = hitPoint(hitAngle, yc, point, rrotation);\n  if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {\n    return seeThroughWithShadow(yc, p, point, rotation, rrotation);\n  }\n  vec4 color = backside(yc, point);\n  vec4 otherColor;\n  if (yc < 0.0) {\n    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n    shado *= pow(-yc / cylinderRadius, 3.0);\n    shado *= 0.5;\n    otherColor = vec4(0.0, 0.0, 0.0, shado);\n  }\n  else {\n    otherColor = getFromColor(p);\n  }\n  color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n  vec4 cl = seeThroughWithShadow(yc, p, point, rotation, rrotation);\n  float dist = distanceToEdge(point);\n  return antiAlias(color, cl, dist);\n}\nvoid main () {\n  gl_FragColor = v_color * transition(v_uv0);\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[],"blocks":[{"name":"Time","members":[{"name":"time","type":13,"count":1}],"defines":[],"binding":0}],"samplers":[{"name":"texture","type":29,"count":1,"defines":[],"binding":30},{"name":"texture2","type":29,"count":1,"defines":[],"binding":31}],"record":null,"name":"inverted-page-curl|vs|fs"}]},{"__type__":"cc.Material","_name":"inverted-page-curl","_effectAsset":{"__uuid__":"51+LVcdatOCJoKPq6rUBxC"},"_techniqueData":{"0":{"defines":{}}}}]